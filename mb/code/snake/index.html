<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Snake</title>
    
    <style>
      canvas {
        position: absolute;
        margin-top: 10;
        margin-left: 10;
        background: black;
        z-index: -1;  /* specifies bottom of the stack, below text, etc */
      }
    </style>
    
  </head>
  <body>

    <!-- create a canvas object -->
    <canvas id="snakecanvas" height="500" width="500"></canvas>
      
    <script>
      
      // save the canvas and context in variables
      var canvas = document.getElementById("snakecanvas");
      var ctx = canvas.getContext("2d");
      
      // load images
      var aImg = new Image();
      var sImg = new Image();
      aImg.src = "apple.png";
      sImg.src = "snake.png";

      // declare constants
      var INIT_X = canvas.width / 2;
      var INIT_Y = canvas.height / 2;
      var CELL_SIZE = 10;
      
      // declare variables
      var interval;
      var stepSpeed;
      var snakeX = [];
      var snakeY = [];
      var appleX = 0;
      var appleY = 0;
      var xDirection = CELL_SIZE;
      var yDirection = CELL_SIZE;
      var snakeLength = 3;
      
      // keyboard handler
      var kbd = function () {
        this.left = false;
        this.right = false;
        this.up = false;
        this.down = false;
        this.p = true;
      };
      
      // initialize game
      function init() {
        stepSpeed = 70;
        snakeLength = 3;
        snakeX = new Array(snakeLength);
        snakeY = new Array(snakeLength);
        snakeX[0] = INIT_X;
        snakeY[0] = INIT_Y;
        xDirection = CELL_SIZE;
        yDirection = CELL_SIZE;
        kbd.left = kbd.up = kbd.p = false;
        kbd.down = kbd.right = false;
        newApple();
        drawScore();
      }
      
      function newApple() {
        var valid = false;
        
        while (!valid) {  // keep attempting to place an apple until valid
          valid = true;
          
          appleX = Math.ceil((Math.random()) * (canvas.width - 30) 
                                / CELL_SIZE) * CELL_SIZE + 10;
          appleY = Math.ceil((Math.random()) * (canvas.width - 30) 
                                / CELL_SIZE) * CELL_SIZE + 10;
          
          for (var i = 0; i < snakeLength; i++) {
            if (appleX === snakeX[i] && appleY === snakeY[i]) {
              valid = false;
              break;
            }
          }
        }
      }
        
      function collisionDetection() {
        
        // munch an apple
        if (snakeX[0] === appleX && snakeY[0] === appleY) {
          newApple();
          snakeLength++;
        }
      
        // left side
        if (snakeX[0] <= 0 + CELL_SIZE) {
          start();
        }
         
        // right side
        else if (snakeX[0] >= canvas.width - CELL_SIZE) {
          start();
        }
        
        // top of canvas
        else if (snakeY[0] <= 0 + CELL_SIZE) {
          start();
        }

        // bottom of screen
        else if (snakeY[0] >= canvas.height - CELL_SIZE) {
          start();
        }
        
        // tail
        for (var i = 2; i < snakeLength; i++) {
          if (snakeX[0] === snakeX[i] && snakeY[0] === snakeY[i]) {
            start();
          }
        }
      }
      
      function moveSnake() {
      
        // handle keyboard presses
        if (kbd.left) {
          xDirection = -CELL_SIZE;
          yDirection = 0;
        }
        else if (kbd.right) {
          xDirection = CELL_SIZE;
          yDirection = 0;
        }
        else if (kbd.up) {
          yDirection = -CELL_SIZE;
          xDirection = 0;
        }
        else if (kbd.down) {
          yDirection = CELL_SIZE;
          xDirection = 0;
        }
        
        // update head position
        snakeX[0] += xDirection;
        snakeY[0] += yDirection;
        
        /* Set each snake part to the coordinates
           of the part before it */
        for (var i = snakeLength; i > 0; i--) {
          snakeX[i] = snakeX[i - 1];
          snakeY[i] = snakeY[i - 1];
        }
      }
      
      function drawSnake() {
          ctx.beginPath();
        for (var i = snakeLength; i > 0; i--) {

          // make a circle 
          //ctx.arc(snakeX[i], snakeY[i], CELL_SIZE / 2, 0, Math.PI * 2);
      
          // set a color for the fill.  hex also works here
          ctx.drawImage(sImg, snakeX[i], snakeY[i]);

        }
          ctx.closePath(); 
      }
      
      function drawApple() {
        ctx.beginPath();
        ctx.drawImage(aImg, appleX, appleY);
        ctx.closePath(); 
      }
      
      // Draw score
      function drawScore() {
        ctx.font = "11px lucida console";
        ctx.fillStyle = "rgb(255, 255, 255)";
        ctx.fillText("munched: " + (snakeLength - 3), 5, 15);
      }
      
      // update will be called each frame
      var update = function() {
      
        // clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // check for pause
        if (kbd.p) pause();
        
        // check for collisions
        collisionDetection();
        
        // update snake coordinates
        moveSnake();
        
        // draw stuff
        drawSnake();
        drawApple();
        drawScore();
      };
      
      // add keyevent listener to track arrow key actions
      document.addEventListener("keydown", function (e) {
        if ((e.keyCode === 39 || e.keyCode === 68) && !kbd.left) {
          kbd.up = kbd.down = kbd.p = false;
          kbd.right = true;
        }
        else if ((e.keyCode === 38 || e.keyCode === 87) && !kbd.down) {
          kbd.left = kbd.right = kbd.p = false;
          kbd.up = true;
        }
        else if ((e.keyCode === 37 || e.keyCode === 65) && !kbd.right) {
          kbd.up = kbd.down = kbd.p = false;
          kbd.left = true;
        }
        else if ((e.keyCode === 40 || e.keyCode === 83) && !kbd.up) {
          kbd.left = kbd.right = kbd.p = false;
          kbd.down = true;
        }
        else if (e.keyCode === 80) {
          kbd.p = true;
        }
      }, false);
      
      function pause() {
        kbd.p = false;
          
        // clear old interval
        clearInterval(interval);
        
        var waiting = setInterval(function() { 
          if (kbd.p) {
            kbd.p = false;
            clearInterval(waiting);
  
            // start or restart the sequence of updates
            interval = setInterval(update, stepSpeed);
          }
        }, 50);
      }
 
      function start() {

        // clear old interval
        clearInterval(interval);
          
        init();
        
        var waiting = setInterval(function() { 
          if (kbd.p || kbd.down || kbd.up ||
              kbd.right || kbd.left) {
            kbd.p = false;
            clearInterval(waiting);
  
            /* Main timer with update function and 
               interval duration as parameters */
            interval = setInterval(update, stepSpeed);
          }
        }, 50);
      }

      
      start(); // go!
      
    </script>
  </body>
</html>