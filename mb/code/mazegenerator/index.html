<!DOCTYPE html>
<html>
  <head>
    <title>Maze generator</title>
  </head>

  <style>
  
    body {
      width: 95%;
    }
    
    table {
      background-color: #fff;
      border-collapse: collapse;
    }

    td {
      border: 1px solid black;
      height: 5px;
      width: 5px;
      background-color: white;
    }

    td.n {
      border-top: 1px solid white;
    }

    td.s {
      border-bottom: 1px solid white;
    }

    td.e {
      border-right: 1px solid white;
    }

    td.w {
      border-left: 1px solid white;
    }
    
    canvas {
      background-color: #fff;
    }

  </style>

  <body>
    <canvas id="mazecanvas" width=1070 height=650></canvas>
    <div id="mazeout"></div>
    
    <script>
      /* todo: fix overdrawing walls, just draw N & E?
       * add solver
       * animate algorithm help:
       * http://stackoverflow.com/questions/17719662/animating-a-recursive-backtracking-algorithm-in-javascript
       * http://stackoverflow.com/questions/29588816/animate-javascript-canvas-while-in-recursive-calculation
       */
      
      // grab canvas and context from DOM
      var canvas = document.getElementById("mazecanvas");
      var ctx = canvas.getContext("2d");
    
      // declare variables
      var grid = 7;
      var width = 150;
      var height = 90;
      var maze = [];

      // represents a maze cell
      var Cell = function (x, y) {
        this.x = x;
        this.y = y;
        this.n = null;
        this.s = null;
        this.e = null;
        this.w = null;
        this.visited = false;
        
        // sets the neighbors for this cell
        this.setNeighbors = function () {
          var dirs = [[0, -1], [0, 1], [1, 0], [-1, 0]];
        
          for (var i = 0; i < dirs.length; i++) {
            if (tile.x + dirs[i][0] >= 0 && 
                tile.y + dirs[i][1] >= 0 &&
                tile.x + dirs[i][0] < this.height && 
                tile.y + dirs[i][1] < this.width) {
              tile.neighbors.push(
                this.tiles[tile.x + dirs[i][0]][tile.y + dirs[i][1]]);
            }
          }
        };
    
        // prepares cell for HTML output
        this.toHTML = function () {
          var output = "<td class='";
          if (this.n) output += "n";
          if (this.s) output += " s";
          if (this.e) output += " e";
          if (this.w) output += " w";
          return output + "'></td>";
        }
        
        // renders cell to canvas
        this.draw = function () {
          var x = this.x * grid + 1;
          var y = this.y * grid + 1;
          
          ctx.beginPath();
          ctx.strokeStyle = "#000000";
          ctx.moveTo(x, y);   
          
          if (this.n) {
            ctx.moveTo(x + grid, y);
          }
          else {
            ctx.lineTo(x + grid, y);
          }
          if (this.e) {
            ctx.moveTo(x + grid, y + grid);
          }
          else {
            ctx.lineTo(x + grid, y + grid);
          }
          if (this.s) {
            ctx.moveTo(x, y + grid);
          }
          else {
            ctx.lineTo(x, y + grid);
          }
          if (this.w) {
            ctx.moveTo(x, y);
          }
          else {
            ctx.lineTo(x, y);
          }
          
          ctx.stroke();
          ctx.closePath();
        }
      };
      
      // initializes a new maze
      function init() {
      
        // make a new 2d maze array
        maze = new Array(height);
        for (var i = 0; i < maze.length; i++) {
          maze[i] = new Array(width);
        }
    
        // add cells to maze array
        for (var i = 0; i < maze.length; i++) {
          for (var j = 0; j < maze[i].length; j++) {
            maze[i][j] = new Cell(j, i);
          }
        }
      }

      // renders the maze as a table
      function print() {
        var s = "<table>";
        for (var i = 0; i < maze.length; i++) {
          s += "<tr>";
          for (var j = 0; j < maze[i].length; j++) {
            s += maze[i][j].toHTML();
          }
          s += "</tr>";
        }
        s += "</table>";
        document.getElementById("mazeout").innerHTML = s;
      }
      
      // renders the maze to canvas
      function draw() {
        for (var i = 0; i < maze.length; i++) {
          for (var j = 0; j < maze[i].length; j++) {
            maze[i][j].draw();
          }
        }
      }
  
      // carve maze with a recursive backtracking algorithm
      function makePath() {
      
        // start at a random cell
        var stack = [maze[Math.floor(Math.random() * maze.length)]
                         [Math.floor(Math.random() * maze[0].length)]];
        
        while (stack.length > 0) {
        
          // make the top of the stack the current cell
          var cell = stack[stack.length - 1];
          
          // add this cell to the animation queue
          animStates.push(cell);
        
          // mark this cell visited
          cell.visited = true;
          
          // get this cell's neighbors in random order
          var neighbors = getNeighbors(cell);
          var randomNeighbors = shuffle(getNeighbors(cell));
          
          // find an unvisited neighbor
          var pop = true;
          for (var i = 0; i < randomNeighbors.length && pop; i++) {
            if (randomNeighbors[i] && !randomNeighbors[i].visited) {
              stack.push(randomNeighbors[i]);
              pop = false;
              
              // make a path between current cell and unvisited neighbor                      
              switch (neighbors.indexOf(randomNeighbors[i])) {
                case 0: cell.n = randomNeighbors[i].s = true; break;
                case 1: cell.s = randomNeighbors[i].n = true; break;
                case 2: cell.e = randomNeighbors[i].w = true; break;
                case 3: cell.w = randomNeighbors[i].e = true; break;
                default: console.log("error");
              }
            }
          }

          // no valid neighbors were found, pop the stack
          if (pop) stack.pop();
        }
      }
      
      // determines neighbors for a maze cell
      function getNeighbors(cell) {
        var dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];
        var neighbors = [];
      
        for (var i = 0; i < dirs.length; i++) {
          if (cell.y + dirs[i][0] >= 0 &&
              cell.x + dirs[i][1] >= 0 &&
              cell.y + dirs[i][0] < height &&
              cell.x + dirs[i][1] < width) {
            neighbors.push(maze[cell.y + dirs[i][0]]
                               [cell.x + dirs[i][1]]);
          }
          else {
            neighbors.push(null);
          }
        }
        return neighbors;
      }
      
      // shuffles an array using fisher-yates
      function shuffle(arr) {
        var i = arr.length;
        while (i > 0) {
          var r = Math.floor(Math.random() * i--);
          var temp = arr[r];
          arr[r] = arr[i];
          arr[i] = temp;
        }
        return arr;
      }

      // initialize a new maze
      init();
      
      // make a queue for animation frames
      var animStates = [];
      
      // start recursively carving out a maze
      makePath();

      // add entry and exit
      maze[0][0].n = true;
      maze[height - 1][width - 1].s = true;

      // render the maze to the HTML document
      setInterval(function () {
        animStates.shift().draw();
      }, 2);
      
    </script>
  </body>
</html>