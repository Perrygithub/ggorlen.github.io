<!DOCTYPE html>
<html>
  <head>
    <title>Maze generator</title>
  </head>

  <style>
  
    body {
      width: 95%;
    }
    
    table {
      background-color: #fff;
      border-collapse: collapse;
    }

    td {
      border: 1px solid black;
      height: 5px;
      width: 5px;
      background-color: white;
    }

    td.n {
      border-top: 1px solid white;
    }

    td.s {
      border-bottom: 1px solid white;
    }

    td.e {
      border-right: 1px solid white;
    }

    td.w {
      border-left: 1px solid white;
    }
    
    canvas {
      background-color: #fff;
    }

  </style>

  <body>
    <canvas id="mazecanvas" width=1070 height=650></canvas>
    <div id="mazeout"></div>
    
    <script>
      /* todo: fix overdrawing walls, just draw N & E?
       * add solver
       * animate algorithm help:
       * http://stackoverflow.com/questions/17719662/animating-a-recursive-backtracking-algorithm-in-javascript
       * http://stackoverflow.com/questions/29588816/animate-javascript-canvas-while-in-recursive-calculation
       */
      
      // grab canvas and context from DOM
      var canvas = document.getElementById("mazecanvas");
      var ctx = canvas.getContext("2d");
    
      // declare variables
      var grid = 7;
      var width = 150;
      var height = 90;
      var maze = [];

      // represents a maze cell
      var Cell = function (x, y) {
        this.x = x;
        this.y = y;
        this.n = null;
        this.s = null;
        this.e = null;
        this.w = null;
        this.visited = false;
        
        // sets the neighbors for this cell
        this.setNeighbors = function () {
          var dirs = [[0, -1], [0, 1], [1, 0], [-1, 0]];
        
          for (var i = 0; i < dirs.length; i++) {
            if (tile.x + dirs[i][0] >= 0 && 
                tile.y + dirs[i][1] >= 0 &&
                tile.x + dirs[i][0] < this.height && 
                tile.y + dirs[i][1] < this.width) {
              tile.neighbors.push(
                this.tiles[tile.x + dirs[i][0]][tile.y + dirs[i][1]]);
            }
          }
        };
    
        // prepares cell for HTML output
        this.toHTML = function () {
          var output = "<td class='";
          if (this.n) output += "n";
          if (this.s) output += " s";
          if (this.e) output += " e";
          if (this.w) output += " w";
          return output + "'></td>";
        }
        
        // renders maze to canvas
        this.draw = function () {
          var x = this.x * grid + 1;
          var y = this.y * grid + 1;
          
          ctx.beginPath();
          ctx.strokeStyle = "#000000";
          ctx.moveTo(x, y);   
          
          if (this.n) {
            ctx.moveTo(x + grid, y);
          }
          else {
            ctx.lineTo(x + grid, y);
          }
          if (this.e) {
            ctx.moveTo(x + grid, y + grid);
          }
          else {
            ctx.lineTo(x + grid, y + grid);
          }
          if (this.s) {
            ctx.moveTo(x, y + grid);
          }
          else {
            ctx.lineTo(x, y + grid);
          }
          if (this.w) {
            ctx.moveTo(x, y);
          }
          else {
            ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.closePath();
        }
      };
      
      // initializes a new maze
      function init() {
      
        // make a new 2d maze array
        maze = new Array(height);
        for (var i = 0; i < maze.length; i++) {
          maze[i] = new Array(width);
        }
    
        // add cells to maze array
        for (var i = 0; i < maze.length; i++) {
          for (var j = 0; j < maze[i].length; j++) {
            maze[i][j] = new Cell(j, i);
          }
        }
        
      }

      // renders the maze as a table
      function print() {
        var s = "<table>";
        for (var i = 0; i < maze.length; i++) {
          s += "<tr>";
          for (var j = 0; j < maze[i].length; j++) {
            s += maze[i][j].toHTML();
          }
          s += "</tr>";
        }
        s += "</table>";
        document.getElementById("mazeout").innerHTML = s;
      }
      
      // renders the maze to canvas
      function draw() {
        for (var i = 0; i < maze.length; i++) {
          for (var j = 0; j < maze[i].length; j++) {
            maze[i][j].draw();
          }
        }
      }
  
      // recursively carve maze
      function makePath(cell) {

        // mark this cell visited
        cell.visited = true;
        
        // get this cell's neighbors in random order
        var neighbors = getNeighbors(cell);
        var randomNeighbors = shuffle(getNeighbors(cell));
        
        for (var i = 0; i < randomNeighbors.length; i++) {
          
          // make a path between current cell and an unvisited neighbor
          if (randomNeighbors[i] && !randomNeighbors[i].visited) {
            switch (neighbors.indexOf(randomNeighbors[i])) {
              case 0:
                cell.n = randomNeighbors[i].s = true; nfrq++;
                break;
              case 1:
                cell.s = randomNeighbors[i].n = true; sfrq++;
                break;
              case 2:
                cell.e = randomNeighbors[i].w = true; efrq++;
                break;
              case 3:
                cell.w = randomNeighbors[i].e = true; wfrq++;
                break;
              default: console.log("error");
            }
            
            // animate algorithm
            setTimeout(function() { cell.draw(); }, 1);

            // go to the next cell and repeat
            makePath(randomNeighbors[i]);
          }
        }
        
        // animate final cell
        setTimeout(function() { cell.draw(); }, 1);
      }
      
      // determines neighbors for a maze cell
      function getNeighbors(cell) {
        var dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];
        var neighbors = [];
      
        for (var i = 0; i < dirs.length; i++) {
          if (cell.y + dirs[i][0] >= 0 &&
              cell.x + dirs[i][1] >= 0 &&
              cell.y + dirs[i][0] < height &&
              cell.x + dirs[i][1] < width) {
            neighbors.push(maze[cell.y + dirs[i][0]]
                               [cell.x + dirs[i][1]]);
          }
          else {
            neighbors.push(null);
          }
        }
        return neighbors;
      }
      
      var nfrq = 0;
      var sfrq = 0;
      var efrq = 0;
      var wfrq = 0;
      
      // shuffles an array using fisher-yates
      function shuffle(arr) {
        var i = arr.length;
        while (i > 0) {
          var r = Math.floor(Math.random() * i--);
          var temp = arr[r];
          arr[r] = arr[i];
          arr[i] = temp;
        }
        return arr;
      }

      // initialize a new maze
      init();
      
      // start recursively carving out a maze
      makePath(maze[0][0]);

      // add entry and exit
      maze[0][0].n = true;
      maze[height - 1][width - 1].s = true;

      // render the maze to the HTML document
      //print();
      
    </script>
  </body>
</html>